// Global variables
let currentEventContainer = null;
let currentEventIndex = null;
let currentUser = null;
let autoSaveTimeout = null;
let isAutoSaving = false;

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    // Set today's date as default
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('recordDate').value = today;
    
    // Initialize form
    initializeForm();
    
    // Initialize Firebase authentication
    initializeAuth();
    
    // Set up auto-save
    setupAutoSave();
});

// Initialize form functionality
function initializeForm() {
    // Add event listeners for form validation
    const inputs = document.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
        input.addEventListener('blur', validateField);
        input.addEventListener('input', clearFieldError);
    });
}

// Field validation
function validateField(event) {
    const field = event.target;
    const value = field.value.trim();
    
    // Remove existing error styling
    field.classList.remove('error');
    
    // Basic validation for required fields
    if (field.hasAttribute('required') && !value) {
        showFieldError(field, 'This field is required');
        return false;
    }
    
    // Email validation
    if (field.type === 'email' && value && !isValidEmail(value)) {
        showFieldError(field, 'Please enter a valid email address');
        return false;
    }
    
    return true;
}

// Show field error
function showFieldError(field, message) {
    field.classList.add('error');
    
    // Remove existing error message
    const existingError = field.parentNode.querySelector('.error-message');
    if (existingError) {
        existingError.remove();
    }
    
    // Add new error message
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    errorDiv.style.color = '#ef4444';
    errorDiv.style.fontSize = '0.875rem';
    errorDiv.style.marginTop = '4px';
    
    field.parentNode.appendChild(errorDiv);
}

// Clear field error
function clearFieldError(event) {
    const field = event.target;
    field.classList.remove('error');
    
    const errorMessage = field.parentNode.querySelector('.error-message');
    if (errorMessage) {
        errorMessage.remove();
    }
}

// Email validation
function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

// Event management functions
function addEvent(containerId) {
    currentEventContainer = containerId;
    currentEventIndex = null;
    
    // Clear modal form
    clearEventModal();
    
    // Show modal
    document.getElementById('eventModal').style.display = 'block';
}

function editEvent(containerId, eventIndex) {
    currentEventContainer = containerId;
    currentEventIndex = eventIndex;
    
    const eventsList = document.getElementById(containerId);
    const eventItem = eventsList.children[eventIndex];
    
    // Extract event data from the DOM
    const eventType = eventItem.querySelector('.event-type').textContent.toLowerCase();
    const eventDate = eventItem.querySelector('.event-date').textContent;
    const eventPlace = eventItem.querySelector('.event-place')?.textContent || '';
    const eventDescription = eventItem.querySelector('.event-description')?.textContent || '';
    
    // Get raw sources (without HTML links) for editing
    const eventSourcesElement = eventItem.querySelector('.event-sources');
    const eventSources = eventSourcesElement ? extractRawSources(eventSourcesElement.innerHTML) : '';
    
    // Populate modal form
    document.getElementById('eventType').value = eventType;
    document.getElementById('eventDate').value = eventDate;
    document.getElementById('eventPlace').value = eventPlace;
    document.getElementById('eventDescription').value = eventDescription;
    document.getElementById('eventSources').value = eventSources;
    
    // Show modal
    document.getElementById('eventModal').style.display = 'block';
}

function saveEvent() {
    const eventType = document.getElementById('eventType').value;
    const eventDate = document.getElementById('eventDate').value;
    const eventDescription = document.getElementById('eventDescription').value;
    const eventPlace = document.getElementById('eventPlace').value;
    const eventSources = document.getElementById('eventSources').value;
    
    // Validate required fields
    if (!eventType || !eventDate) {
        alert('Please fill in at least the event type and date.');
        return;
    }
    
    const eventData = {
        type: eventType,
        date: eventDate,
        description: eventDescription,
        place: eventPlace,
        sources: eventSources
    };
    
    if (currentEventIndex !== null) {
        // Edit existing event
        updateEventInDOM(currentEventContainer, currentEventIndex, eventData);
    } else {
        // Add new event
        addEventToDOM(currentEventContainer, eventData);
    }
    
    closeEventModal();
}

function addEventToDOM(containerId, eventData) {
    const eventsList = document.getElementById(containerId);
    const eventItem = createEventElement(eventData);
    eventsList.appendChild(eventItem);
}

function updateEventInDOM(containerId, eventIndex, eventData) {
    const eventsList = document.getElementById(containerId);
    const eventItem = createEventElement(eventData);
    eventsList.replaceChild(eventItem, eventsList.children[eventIndex]);
}

function createEventElement(eventData) {
    const eventDiv = document.createElement('div');
    eventDiv.className = 'event-item';
    
    const formattedDate = formatDate(eventData.date);
    const eventType = eventData.type.charAt(0).toUpperCase() + eventData.type.slice(1);
    const formattedSources = formatSourcesWithLinks(eventData.sources || '');
    const hasSources = eventData.sources && eventData.sources.trim();
    const sourcesId = 'sources-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    
    eventDiv.innerHTML = `
        <div class="event-header">
            <div class="event-type">${eventType}</div>
            <div class="event-actions">
                <button class="btn-small btn-edit" onclick="editEvent('${currentEventContainer}', ${Array.from(document.getElementById(currentEventContainer).children).indexOf(eventDiv)})">Edit</button>
                <button class="btn-small btn-delete" onclick="deleteEvent(this)">Delete</button>
            </div>
        </div>
        <div class="event-content">
            <div class="event-date">${formattedDate}</div>
            ${eventData.description ? `<div class="event-description">${eventData.description}</div>` : ''}
            ${eventData.place ? `<div class="event-place">${eventData.place}</div>` : ''}
            ${hasSources ? `
                <div class="sources-container">
                    <div class="event-sources collapsed" id="${sourcesId}">
                        ${formattedSources}
                    </div>
                    <button class="sources-toggle" onclick="toggleSources('${sourcesId}')">Show more</button>
                </div>
            ` : ''}
        </div>
    `;
    
    return eventDiv;
}

function deleteEvent(button) {
    if (confirm('Are you sure you want to delete this event?')) {
        const eventItem = button.closest('.event-item');
        eventItem.remove();
    }
}

function closeEventModal() {
    document.getElementById('eventModal').style.display = 'none';
    clearEventModal();
}

function clearEventModal() {
    document.getElementById('eventType').value = 'birth';
    document.getElementById('eventDate').value = '';
    document.getElementById('eventDescription').value = '';
    document.getElementById('eventPlace').value = '';
    document.getElementById('eventSources').value = '';
}

// Date formatting
function formatDate(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
}

// Format sources with clickable links
function formatSourcesWithLinks(sources) {
    if (!sources) return '';
    
    // URL regex pattern to match various URL formats
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    
    return sources.replace(urlRegex, (url) => {
        // Clean up the URL (remove trailing punctuation)
        const cleanUrl = url.replace(/[.,;:!?]+$/, '');
        const displayUrl = cleanUrl.length > 50 ? cleanUrl.substring(0, 50) + '...' : cleanUrl;
        
        return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="source-link">${displayUrl}</a>`;
    });
}

// Extract raw sources from HTML (for editing)
function extractRawSources(htmlSources) {
    if (!htmlSources) return '';
    
    // Create a temporary div to parse HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlSources;
    
    // Replace all links with their href values
    const links = tempDiv.querySelectorAll('a.source-link');
    links.forEach(link => {
        const href = link.getAttribute('href');
        link.replaceWith(href);
    });
    
    return tempDiv.textContent || tempDiv.innerText || '';
}

// Toggle sources expansion
function toggleSources(sourcesId) {
    const sourcesElement = document.getElementById(sourcesId);
    const toggleButton = sourcesElement.nextElementSibling;
    
    if (sourcesElement.classList.contains('collapsed')) {
        sourcesElement.classList.remove('collapsed');
        sourcesElement.classList.add('expanded');
        toggleButton.textContent = 'Show less';
    } else {
        sourcesElement.classList.remove('expanded');
        sourcesElement.classList.add('collapsed');
        toggleButton.textContent = 'Show more';
    }
}

// Children management functions
function addChild() {
    const childrenList = document.getElementById('childrenList');
    
    const childId = generateChildId();
    const childDiv = document.createElement('div');
    childDiv.className = 'child-item';
        childDiv.innerHTML = `
            <div class="child-header">
                <input type="text" class="child-name-input" placeholder="Child's Name" id="childName${childId}" name="childName${childId}">
                <div class="child-actions">
                    <button class="btn-small btn-delete" onclick="deleteChild(this)">Delete</button>
                </div>
            </div>
            <div class="spouses-section">
                <h5>Spouses</h5>
                <div class="spouses-list" id="spousesList${childId}">
                    <!-- Spouses will be added here -->
                </div>
                <button type="button" class="add-spouse-btn" onclick="addSpouse(${childId})">+ Add Spouse</button>
            </div>
        `;
    
    childrenList.appendChild(childDiv);
}

function addSpouse(childId) {
    const spousesList = document.getElementById(`spousesList${childId}`);
    
    const spouseDiv = document.createElement('div');
    spouseDiv.className = 'spouse-item';
    spouseDiv.innerHTML = `
        <input type="text" class="spouse-input" placeholder="Spouse's Name" name="spouse_${childId}_${Date.now()}">
        <button class="btn-small btn-delete" onclick="deleteSpouse(this)">Delete</button>
    `;
    
    spousesList.appendChild(spouseDiv);
}

function deleteSpouse(button) {
    if (confirm('Are you sure you want to delete this spouse?')) {
        const spouseItem = button.closest('.spouse-item');
        spouseItem.remove();
    }
}

function deleteChild(button) {
    if (confirm('Are you sure you want to delete this child and all their information?')) {
        const childItem = button.closest('.child-item');
        childItem.remove();
    }
}

// Form management functions
function clearForm() {
    if (confirm('Are you sure you want to clear all form data? This action cannot be undone.')) {
        // Clear all input fields
        const inputs = document.querySelectorAll('input, textarea, select');
        inputs.forEach(input => {
            if (input.type !== 'date' || input.id === 'recordDate') {
                input.value = '';
            }
        });
        
        // Set today's date as default
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('recordDate').value = today;
        
        // Clear all events
        const eventContainers = ['fatherEvents', 'motherEvents'];
        eventContainers.forEach(containerId => {
            document.getElementById(containerId).innerHTML = '';
        });
        
        // Clear all children
        document.getElementById('childrenList').innerHTML = '';
        
        // Clear any error messages
        const errorMessages = document.querySelectorAll('.error-message');
        errorMessages.forEach(error => error.remove());
        
        // Remove error styling
        const errorFields = document.querySelectorAll('.error');
        errorFields.forEach(field => field.classList.remove('error'));
    }
}

function saveRecord() {
    // Validate form
    if (!validateForm()) {
        alert('Please fill in all required fields before saving.');
        return;
    }
    
    // Collect form data
    const formData = collectFormData();
    
    // Save to localStorage
    const recordId = 'fgr_' + Date.now();
    localStorage.setItem(recordId, JSON.stringify(formData));
    
    // Show success message
    alert('Record saved successfully!');
    
    // Optional: Show saved records
    showSavedRecords();
}

function validateForm() {
    const requiredFields = [
        'fatherFullName',
        'motherFullName',
        'preparerName',
        'preparerEmail'
    ];
    
    let isValid = true;
    
    requiredFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (!field.value.trim()) {
            showFieldError(field, 'This field is required');
            isValid = false;
        }
    });
    
    return isValid;
}

// Collect form data using FormData
function collectFormData() {
    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);

    // Convert FormData to a plain object
    const data = {};
    for (let [key, value] of formData.entries()) {
        data[key] = value;
    }

    console.log("data", structuredClone(data));
    data.created = new Date().toISOString();
    return data;
}

// Alternative: Get all form values as a simple object
function getAllFormValues() {
    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);
    
    // Convert FormData to a plain object
    const values = {};
    for (let [key, value] of formData.entries()) {
        values[key] = value;
    }
    
    return values;
}

// Get form values with nested structure (more organized)
function getFormValuesStructured() {
    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);
    
    // Convert FormData to a plain object first
    const flatData = {};
    for (let [key, value] of formData.entries()) {
        flatData[key] = value;
    }
    
    // Structure the data
    return {
        recordDate: flatData.recordDate || '',
        father: {
            name: flatData.fatherFullName || '',
            father: flatData.fatherFather || '',
            mother: flatData.fatherMother || '',
            events: collectEvents('fatherEvents')
        },
        mother: {
            name: flatData.motherFullName || '',
            father: flatData.motherFather || '',
            mother: flatData.motherMother || '',
            events: collectEvents('motherEvents')
        },
        children: collectChildren(),
        preparer: {
            name: flatData.preparerName || '',
            address: flatData.preparerAddress || '',
            email: flatData.preparerEmail || ''
        },
        comments: flatData.comments || '',
        created: new Date().toISOString()
    };
}

// ==================== UUID UTILITY FUNCTIONS ====================

// Generate a UUID v4 (random UUID)
function generateUUID() {
    // Check if crypto.randomUUID is available (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    
    // Fallback for older browsers
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Generate a shorter UUID (8 characters)
function generateShortUUID() {
    return Math.random().toString(36).substr(2, 8);
}

// Generate a numeric ID
function generateNumericID() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 5);
}

// Generate a custom ID with prefix
function generateCustomID(prefix = 'id') {
    return `${prefix}_${generateUUID()}`;
}

// Make UUID functions available globally
window.generateUUID = generateUUID;
window.generateShortUUID = generateShortUUID;
window.generateNumericID = generateNumericID;
window.generateCustomID = generateCustomID;

// ==================== ARRAY UTILITY FUNCTIONS ====================

// Group array elements by a key function
function groupBy(array, keyFunction) {
    if (!Array.isArray(array)) {
        throw new Error('First argument must be an array');
    }
    
    if (typeof keyFunction !== 'function') {
        throw new Error('Second argument must be a function');
    }
    
    return array.reduce((groups, item, index) => {
        const key = keyFunction(item, index);
        const keyString = String(key);
        
        if (!groups[keyString]) {
            groups[keyString] = [];
        }
        
        groups[keyString].push(item);
        return groups;
    }, {});
}

// Group by property name (shorthand for simple property grouping)
function groupByProperty(array, propertyName) {
    return groupBy(array, item => item[propertyName]);
}

// Group by multiple properties
function groupByMultiple(array, propertyNames) {
    return groupBy(array, item => {
        return propertyNames.map(prop => item[prop]).join('|');
    });
}

// Group and transform the result
function groupByAndTransform(array, keyFunction, transformFunction) {
    const grouped = groupBy(array, keyFunction);
    const result = {};
    
    for (const [key, items] of Object.entries(grouped)) {
        result[key] = transformFunction(items, key);
    }
    
    return result;
}

// Group by and count occurrences
function groupByAndCount(array, keyFunction) {
    return groupByAndTransform(array, keyFunction, items => items.length);
}

// Group by and get unique values
function groupByAndUnique(array, keyFunction, valueFunction) {
    return groupByAndTransform(array, keyFunction, items => {
        const values = items.map(valueFunction);
        return [...new Set(values)];
    });
}

// Group by and aggregate (sum, average, etc.)
function groupByAndAggregate(array, keyFunction, valueFunction, aggregateFunction) {
    return groupByAndTransform(array, keyFunction, items => {
        const values = items.map(valueFunction);
        return aggregateFunction(values);
    });
}

// Convert grouped object back to array
function groupedToArray(groupedObject, keyName = 'key', itemsName = 'items') {
    return Object.entries(groupedObject).map(([key, items]) => ({
        [keyName]: key,
        [itemsName]: items
    }));
}

// ==================== FORMDATA UTILITY FUNCTIONS ====================

// Simple function to get all form values as a flat object
function getFormDataAsObject() {
    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);
    
    // Convert FormData to a plain object
    const result = {};
    for (let [key, value] of formData.entries()) {
        result[key] = value;
    }
    
    return result;
}

// Get form data as FormData object (for direct use with fetch/XMLHttpRequest)
function getFormDataAsFormData() {
    const form = document.getElementById('familyGroupForm');
    return new FormData(form);
}

// Get form data as URLSearchParams (for URL encoding)
function getFormDataAsURLParams() {
    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);
    return new URLSearchParams(formData);
}

// Get form data as JSON string
function getFormDataAsJSON() {
    const formData = getFormDataAsObject();
    return JSON.stringify(formData, null, 2);
}

// Debug function to log all form values
function debugFormValues() {
    console.log('=== FORM VALUES DEBUG ===');
    console.log('As Object:', getFormDataAsObject());
    console.log('As JSON:', getFormDataAsJSON());
    console.log('As URL Params:', getFormDataAsURLParams().toString());
    console.log('========================');
}

// Make debug function available globally for testing
window.debugFormValues = debugFormValues;

function collectEvents(containerId) {
    const events = [];
    const eventsList = document.getElementById(containerId);
    
    Array.from(eventsList.children).forEach(eventItem => {
        const event = {
            type: eventItem.querySelector('.event-type').textContent.toLowerCase(),
            date: eventItem.querySelector('.event-date').textContent,
            place: eventItem.querySelector('.event-place')?.textContent || '',
            description: eventItem.querySelector('.event-description')?.textContent || '',
            sources: eventItem.querySelector('.event-sources')?.textContent || ''
        };
        events.push(event);
    });
    
    return events;
}

function collectChildren() {
    const children = [];
    const childrenList = document.getElementById('childrenList');
    
    Array.from(childrenList.children).forEach(childItem => {
        const childName = childItem.querySelector('.child-name-input').value;
        const spouses = [];
        
        const spousesList = childItem.querySelector('.spouses-list');
        Array.from(spousesList.children).forEach(spouseItem => {
            const spouseName = spouseItem.querySelector('.spouse-input').value;
            if (spouseName.trim()) {
                spouses.push(spouseName);
            }
        });
        
        if (childName.trim()) {
            children.push({
                name: childName,
                spouses: spouses
            });
        }
    });
    
    return children;
}

function exportRecord() {
    if (!validateForm()) {
        alert('Please fill in all required fields before exporting.');
        return;
    }
    
    const formData = collectFormData();
    
    // Create a formatted text version
    const textContent = formatRecordAsText(formData);
    
    // Create and download file
    const blob = new Blob([textContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `FamilyGroupRecord_${formData.father.name}_${formData.mother.name}_${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function formatRecordAsText(data) {
    let content = `FAMILY GROUP RECORD\n`;
    content += `Record Date: ${data.recordDate}\n`;
    content += `Family of ${data.father.name} and ${data.mother.name}\n\n`;
    
    // Father section
    content += `FATHER: ${data.father.name}\n`;
    if (data.father.father) content += `  Father: ${data.father.father}\n`;
    if (data.father.mother) content += `  Mother: ${data.father.mother}\n`;
    if (data.father.events.length > 0) {
        content += `  Events:\n`;
        data.father.events.forEach(event => {
            content += `    ${event.type.toUpperCase()}: ${event.date}`;
            if (event.place) content += ` | ${event.place}`;
            if (event.description) content += ` | ${event.description}`;
            if (event.sources) content += ` | Sources: ${event.sources}`;
            content += `\n`;
        });
    }
    content += `\n`;
    
    // Mother section
    content += `MOTHER: ${data.mother.name}\n`;
    if (data.mother.father) content += `  Father: ${data.mother.father}\n`;
    if (data.mother.mother) content += `  Mother: ${data.mother.mother}\n`;
    if (data.mother.events.length > 0) {
        content += `  Events:\n`;
        data.mother.events.forEach(event => {
            content += `    ${event.type.toUpperCase()}: ${event.date}`;
            if (event.place) content += ` | ${event.place}`;
            if (event.description) content += ` | ${event.description}`;
            if (event.sources) content += ` | Sources: ${event.sources}`;
            content += `\n`;
        });
    }
    content += `\n`;
    
    // Children section
    if (data.children.length > 0) {
        content += `CHILDREN:\n`;
        data.children.forEach((child, index) => {
            content += `  ${index + 1}. ${child.name}`;
            if (child.spouses.length > 0) {
                content += ` (Spouses: ${child.spouses.join(', ')})`;
            }
            content += `\n`;
        });
        content += `\n`;
    }
    
    // Preparer section
    content += `PREPARER:\n`;
    content += `  Name: ${data.preparer.name}\n`;
    if (data.preparer.address) content += `  Address: ${data.preparer.address}\n`;
    if (data.preparer.email) content += `  Email: ${data.preparer.email}\n`;
    content += `\n`;
    
    // Comments section
    if (data.comments) {
        content += `COMMENTS:\n${data.comments}\n`;
    }
    
    content += `\nGenerated on: ${new Date().toLocaleString()}`;
    
    return content;
}

function showSavedRecords() {
    const records = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('fgr_')) {
            const record = JSON.parse(localStorage.getItem(key));
            records.push({
                id: key,
                name: `${record.father.name} & ${record.mother.name}`,
                date: record.recordDate,
                created: record.created
            });
        }
    }
    
    if (records.length === 0) {
        alert('No saved records found.');
        return;
    }
    
    // Create a simple list of saved records
    let message = 'Saved Records:\n\n';
    records.forEach((record, index) => {
        message += `${index + 1}. ${record.name} (${record.date})\n`;
    });
    
    alert(message);
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('eventModal');
    if (event.target === modal) {
        closeEventModal();
    }
}

// Keyboard shortcuts
document.addEventListener('keydown', function(event) {
    // Escape key to close modal
    if (event.key === 'Escape') {
        closeEventModal();
    }
    
    // Ctrl+S to save
    if (event.ctrlKey && event.key === 's') {
        event.preventDefault();
        saveRecord();
    }
    
    // Ctrl+E to export
    if (event.ctrlKey && event.key === 'e') {
        event.preventDefault();
        exportRecord();
    }
});

// ==================== FIREBASE AUTHENTICATION ====================

// Initialize Firebase authentication
function initializeAuth() {
    if (!window.firebase) {
        console.error('Firebase not loaded. Please check your Firebase configuration.');
        return;
    }
    
    const { onAuthStateChanged } = window.firebase;
    
    // Listen for authentication state changes
    onAuthStateChanged(window.firebase.auth, (user) => {
        currentUser = user;
        updateAuthUI(user);
        
        if (user) {
            console.log('User signed in:', user.displayName);
            loadUserData();
        } else {
            console.log('User signed out');
            clearForm();
        }
    });
    
    // Set up login/logout button event listeners
    document.getElementById('loginBtn').addEventListener('click', signInWithGoogle);
    document.getElementById('logoutBtn').addEventListener('click', signOutUser);
}

// Sign in with Google
async function signInWithGoogle() {
    try {
        const { signInWithPopup, provider } = window.firebase;
        const result = await signInWithPopup(window.firebase.auth, provider);
        console.log('Sign-in successful:', result.user);
    } catch (error) {
        console.error('Sign-in error:', error);
        alert('Sign-in failed. Please try again.');
    }
}

// Sign out user
async function signOutUser() {
    try {
        const { signOut } = window.firebase;
        await signOut(window.firebase.auth);
        console.log('Sign-out successful');
    } catch (error) {
        console.error('Sign-out error:', error);
        alert('Sign-out failed. Please try again.');
    }
}

// Update authentication UI
function updateAuthUI(user) {
    const userInfo = document.getElementById('userInfo');
    const loginSection = document.getElementById('loginSection');
    const userName = document.getElementById('userName');
    
    if (user) {
        // User is signed in
        userInfo.style.display = 'flex';
        loginSection.style.display = 'none';
        userName.textContent = user.displayName || user.email;
    } else {
        // User is signed out
        userInfo.style.display = 'none';
        loginSection.style.display = 'block';
    }
}

// ==================== FIRESTORE INTEGRATION ====================

// Save data to Firestore
async function saveToFirestore(data) {
    if (!currentUser) {
        console.log('No user signed in, saving to localStorage instead');
        return saveToLocalStorage(data);
    }
    
    try {
        const { doc, setDoc } = window.firebase;
        const userDocRef = doc(window.firebase.db, 'users', currentUser.uid);
        
        const userData = {
            ...data,
            lastUpdated: new Date().toISOString(),
            userId: currentUser.uid
        };
        
        await setDoc(userDocRef, userData, { merge: true });
        console.log('Data saved to Firestore successfully');
        return true;
    } catch (error) {
        console.error('Error saving to Firestore:', error);
        // Fallback to localStorage
        return saveToLocalStorage(data);
    }
}

// Load data from Firestore
async function loadFromFirestore() {
    if (!currentUser) {
        console.log('No user signed in, loading from localStorage instead');
        return loadFromLocalStorage();
    }
    
    try {
        const { doc, getDoc } = window.firebase;
        const userDocRef = doc(window.firebase.db, 'users', currentUser.uid);
        const docSnap = await getDoc(userDocRef);
        
        if (docSnap.exists()) {
            const data = docSnap.data();
            console.log('Data loaded from Firestore:', data);
            populateForm(data);
            return data;
        } else {
            console.log('No data found in Firestore');
            return null;
        }
    } catch (error) {
        console.error('Error loading from Firestore:', error);
        // Fallback to localStorage
        return loadFromLocalStorage();
    }
}

// Save to localStorage (fallback)
function saveToLocalStorage(data) {
    try {
        const recordId = 'fgr_' + Date.now();
        localStorage.setItem(recordId, JSON.stringify(data));
        console.log('Data saved to localStorage');
        return true;
    } catch (error) {
        console.error('Error saving to localStorage:', error);
        return false;
    }
}

// Load from localStorage (fallback)
function loadFromLocalStorage() {
    try {
        // Find the most recent record
        let latestRecord = null;
        let latestTime = 0;
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('fgr_')) {
                const record = JSON.parse(localStorage.getItem(key));
                const recordTime = new Date(record.created || 0).getTime();
                if (recordTime > latestTime) {
                    latestTime = recordTime;
                    latestRecord = record;
                }
            }
        }
        
        if (latestRecord) {
            console.log('Data loaded from localStorage:', latestRecord);
            populateForm(latestRecord);
            return latestRecord;
        }
        
        return null;
    } catch (error) {
        console.error('Error loading from localStorage:', error);
        return null;
    }
}

// Populate form with data
function populateForm(data) {
    if (!data) return;
    
    // Populate basic fields
    if (data.recordDate) document.getElementById('recordDate').value = data.recordDate;


    const form = document.getElementById('familyGroupForm');
    const formData = new FormData(form);
    for (let [key, value] of formData.entries()) {
        console.log("key", key, "value", value);
        document.getElementById(key).value = data[key];
    }

    // handle adding the children to the form
    console.log("data", data);
    console.log("formData", Object.entries(data));
    const childData = Object.entries(data).filter(([key, value])=> key.startsWith('child'))
    console.log("childData", childData);

    const groupedData = groupBy(childData, ([key, value])=> key.split('__')[1])
    console.log("groupedData", groupedData);
    

    





    // if (data.father) {
    //     if (data.father.name) document.getElementById('fatherFullName').value = data.father.name;
    //     if (data.father.father) document.getElementById('fatherFather').value = data.father.father;
    //     if (data.father.mother) document.getElementById('fatherMother').value = data.father.mother;
    //     if (data.father.events) populateEvents('fatherEvents', data.father.events);
    // }
    // if (data.mother) {
    //     if (data.mother.name) document.getElementById('motherFullName').value = data.mother.name;
    //     if (data.mother.father) document.getElementById('motherFather').value = data.mother.father;
    //     if (data.mother.mother) document.getElementById('motherMother').value = data.mother.mother;
    //     if (data.mother.events) populateEvents('motherEvents', data.mother.events);
    // }
    // if (data.children) populateChildren(data.children);
    // if (data.preparer) {
    //     if (data.preparer.name) document.getElementById('preparerName').value = data.preparer.name;
    //     if (data.preparer.address) document.getElementById('preparerAddress').value = data.preparer.address;
    //     if (data.preparer.email) document.getElementById('preparerEmail').value = data.preparer.email;
    // }
    // if (data.comments) document.getElementById('comments').value = data.comments;
}

// Populate events
function populateEvents(containerId, events) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    events.forEach(eventData => {
        const eventElement = createEventElement(eventData);
        container.appendChild(eventElement);
    });
}

// Populate children
function populateChildren(children) {
    const childrenList = document.getElementById('childrenList');
    childrenList.innerHTML = '';
    
    children.forEach(childData => {
        const childId = generateChildId();
        const childDiv = document.createElement('div');
        childDiv.id = `child${childId}`;
        childDiv.className = 'child-item';
        childDiv.innerHTML = `
            <div class="child-header">
                <input type="text" class="child-name-input" placeholder="Child's Name" value="${childData.name || ''}" id="childName${childId}" name="childName${childId}">
                <div class="child-actions">
                    <button class="btn-small btn-delete" onclick="deleteChild(this)">Delete</button>
                </div>
            </div>
            <div class="spouses-section">
                <h5>Spouses</h5>
                <div class="spouses-list" id="spousesList${childId}">
                    ${childData.spouses ? childData.spouses.map((spouse, index) => `
                        <div class="spouse-item">
                            <input type="text" class="spouse-input" placeholder="Spouse's Name" value="${spouse}" name="spouse_${childId}_${index}">
                            <button class="btn-small btn-delete" onclick="deleteSpouse(this)">Delete</button>
                        </div>
                    `).join('') : ''}
                </div>
                <button type="button" class="add-spouse-btn" onclick="addSpouse(${childId})">+ Add Spouse</button>
            </div>
        `;
        childrenList.appendChild(childDiv);
    });
}

// Load user data
async function loadUserData() {
    if (!currentUser) return;
    
    try {
        await loadFromFirestore();
    } catch (error) {
        console.error('Error loading user data:', error);
    }
}

// ==================== AUTO-SAVE FUNCTIONALITY ====================

// Set up auto-save
function setupAutoSave() {
    const form = document.getElementById('familyGroupForm');
    form.addEventListener('input', debounceAutoSave);
    form.addEventListener('change', debounceAutoSave);
}

// Debounced auto-save
function debounceAutoSave() {
    if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
    }
    
    autoSaveTimeout = setTimeout(() => {
        if (currentUser) {
            autoSave();
        }
    }, 500); // Auto-save after 2 seconds of inactivity
}

// Auto-save function
async function autoSave() {
    if (isAutoSaving) return;
    
    isAutoSaving = true;
    
    try {
        const formData = collectFormData();
        const success = await saveToFirestore(formData);
        
        if (success) {
            showAutoSaveIndicator('Saved automatically');
        }
    } catch (error) {
        console.error('Auto-save error:', error);
    } finally {
        isAutoSaving = false;
    }
}

// Show auto-save indicator
function showAutoSaveIndicator(message) {
    // Create or update auto-save indicator
    let indicator = document.getElementById('autoSaveIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autoSaveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.textContent = message;
    indicator.style.opacity = '1';
    
    setTimeout(() => {
        indicator.style.opacity = '0';
    }, 3000);
}

// Override the original saveRecord function to use Firestore
const originalSaveRecord = saveRecord;
saveRecord = async function() {
    if (!validateForm()) {
        alert('Please fill in all required fields before saving.');
        return;
    }
    
    const formData = collectFormData();
    const success = await saveToFirestore(formData);
    
    if (success) {
        alert('Record saved successfully!');
    } else {
        alert('Failed to save record. Please try again.');
    }
};

function generateChildId(){
    return `__child${generateNumericID()}`;
}

function generateSpouseId(childId){
    return `__spouse${generateNumericID()}_${childId}`;
}